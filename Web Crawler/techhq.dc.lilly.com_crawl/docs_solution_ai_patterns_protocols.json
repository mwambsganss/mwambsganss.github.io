{
  "url": "https://techhq.dc.lilly.com/docs/solution/ai/patterns/protocols",
  "title": "Protocols | Tech HQ",
  "description": "Last Updated: July 25, 2025",
  "h1": [
    "Protocols",
    "Agent to Tool Communication",
    "Agent to Agent Communication",
    "References"
  ],
  "h2": [
    "Industry Standard Protocols‚Äã",
    "Model Context Protocol (MCP)‚Äã",
    "Agent2Agent (A2A) Protocol‚Äã"
  ],
  "h3": [
    "Emerging Standards‚Äã",
    "Overview and Purpose‚Äã",
    "Architecture and Components‚Äã",
    "Core Primitives‚Äã",
    "Transport Mechanisms‚Äã",
    "Benefits and Ecosystem‚Äã",
    "Protocol Comparison for Agent-Tool Communication‚Äã",
    "MCP Roadmap at Lilly‚Äã",
    "Key Components of an A2A Protocol‚Äã",
    "Key Features and Capabilities‚Äã",
    "A2A and MCP: Complementary Protocols‚Äã",
    "How A2A Works‚Äã",
    "Agent Cards‚Äã",
    "The Challenges of Agent Communication‚Äã",
    "Benefits of A2A‚Äã",
    "A2A Design Principles‚Äã",
    "Agent2Agent Roadmap at Lilly‚Äã",
    "The Future of Agent Interoperability‚Äã",
    "What's Next: Protocol Roadmap‚Äã"
  ],
  "text_content": "Protocols | Tech HQ\nSkip to main content\nTech HQ\nInnovate\nPlan\nSolution\nAccess\nLearn\nContribute\nUpdates\nLillyFlow\nüß© Solution Overview\nü§ñ AI & Intelligent Agents\nEcosystem\nPatterns\nQuantum Computing\nAgentic\nWorkflows\nBuilding Agentic Patterns\nContext Engineering\nDeep Agents\nDeep Research\nModel Foundry\nProtocols\nPositioning\nExamples\nCoding Tools\nStandards\nAI Submission Guide Template\nüóÑÔ∏è AI & Intelligent Agents BLT\nü§ñ Agentic AI\nüß≠ Conversational AI\nüß≠ Knowledge Bases\nüß≠ Multimodal AI\nüß≠ Translation Services\nüè¢ Business Enablement\n‚òÅÔ∏è Cloud & Infrastructure\nüîê Cybersecurity\nüìä Data & Analytics\nüõ†Ô∏è Engineering Enablement\nüõ∞Ô∏è Observability & Reliability\nüöÄ Team Productivity\nüé® User Experience & Design\nü§ñ AI & Intelligent Agents\nPatterns\nProtocols\nOn this page\nProtocols\nDocument Information\nLast Updated:\nJuly 25, 2025\nOwner:\nBrian Lewis\nPoint of Contact:\nAli Kharazmi\nContributors and Reviewers:\nArchit Kaila, Haitham Maya, Malika Mahoui\nThis section outlines key communication protocols used for agent-to-agent and agent-tool interactions, highlighting\ncurrent practices and emerging trends in AI system design.\nIndustry Standard Protocols\n‚Äã\nIndustry-standard communication protocols for distributed systems include a mix of synchronous APIs and asynchronous\nmessaging:\nREST/HTTP (JSON)\n‚Äì Simple, stateless, and widely supported. REST uses URIs and JSON over HTTP, making it ideal for\ninteroperability but less suited for streaming or large payload efficiency.\ngRPC / Protocol Buffers\n‚Äì A fast, strongly-typed RPC system using HTTP/2 and binary Protobuf. Supports bidirectional\nstreaming and outperforms REST in high-throughput scenarios with auto-generated code across languages.\nGraphQL\n‚Äì A flexible query API that allows clients to request only needed data via a single endpoint. Best for\ncomplex, nested data models and diverse client needs.\nWebSockets / SSE\n‚Äì Real-time communication protocols. WebSockets enable two-way persistent connections, while SSE\nsupports one-way server-to-client streams. Useful for interactive or live-update applications.\nMessage Queues / Event Streams\n‚Äì Enable decoupled, asynchronous communication. MQTT is lightweight for IoT, while\nKafka and RabbitMQ support scalable, reliable pub/sub messaging across services.\nMainCategories\nAgentProtocols\nModel Context Protocol\nAgent-tool standard\nTool discovery\nStandardized interfaces\nAgent2Agent Protocol\nAgent-agent communication\nAgent discovery\nTask coordination\nAsyncProtocols\nWebSockets\nBi-directional streams\nPersistent connection\nReal-time updates\nMessage Queues\nDecoupled processing\nAsynchronous processing\nHigh scalability\nServer-Sent Events\nServer push updates\nSyncProtocols\nREST/HTTP\nSimple, ubiquitous\nStateless\nHuman-readable\ngRPC\nHigh-performance, streaming\nBinary encoding\nCode generation\nStreaming support\nGraphQL\nFlexible queries\nPrecise queries\nSingle endpoint\nCommunication Protocols\nSynchronous Protocols\nAsynchronous Protocols\nAgent-Specific Protocols\nEmerging Standards\n‚Äã\nThe W3C is actively developing two critical community groups focused on agent standardization:\nThe\nAutonomous Agents on the Web (WebAgents) Community Group\nfocuses on hypermedia Multi-Agent Systems that\nleverage Semantic Web standards.\nThe\nAI Agent Protocol Community Group\nis standardizing inter-agent communication protocols with PKI-based identity\nframeworks and cross-origin security mechanisms.\nThe IETF has introduced groundbreaking standards including:\nThe\nagent:// URI Protocol\nprovides a layered architecture supporting minimal to full-featured agent\nimplementations with the format:\nagent:[+<protocol>]://<authority>/<path>[?<query>][#<fragment>]\nThe\nAgent Name Service (ANS)\nspecification introduces DNS-inspired hierarchical agent addressing with PKI-based\ntrust.\nModern AI applications often mix these protocols. For example, many cloud AI tool APIs are offered as HTTPS/JSON\nservices (REST) for ease of integration, while high-performance backends might expose gRPC. In addition, AI-specific\nstandards are emerging: Anthropic's\nModel Context Protocol (MCP)\nand Google's\nAgent2Agent (A2A)\naim to\nstandardize agent‚Äìtool and agent‚Äìagent interfaces.\nAgent to Tool Communication\nModel Context Protocol (MCP)\n‚Äã\nOverview and Purpose\n‚Äã\nThe Model Context Protocol (MCP), developed by Anthropic, is a standardized JSON-based protocol that creates a universal\ninterface between AI models and tools. Acting as a \"USB-C port for AI,\" MCP enables any LLM to connect to any compliant\ntool or data source in a consistent way.\nMCP defines:\nHow tools describe their capabilities (functions, arguments, schemas)\nHow AI agents discover and invoke those functions\nHow responses (synchronous or streaming) are handled and returned\nThis standardization creates true interoperability between tools and models across vendors, allowing AI systems to query\ndatabases, call APIs, manipulate files, and access various services through a unified protocol.\nExternal Tool (MCP Server)\nAI Agent (MCP Client)\nApp or Orchestrator\nExternal Tool (MCP Server)\nAI Agent (MCP Client)\nApp or Orchestrator\nInstruction (e.g., \"Check calendar\")\nJSON Request via MCP\nResult or Event Stream\nFinal Output\nArchitecture and Components\n‚Äã\nMCP follows a client-host-server architecture with clearly defined roles:\nMCP Hosts\n: Applications like Claude Desktop, IDEs, or custom applications that initiate interactions\nMCP Clients\n: Protocol clients (typically AI models) that maintain connections with servers\nMCP Servers\n: Lightweight programs exposing specific capabilities through the standardized protocol\nData Sources\n: Local files/databases or remote services that MCP servers can securely access\nThis separation of concerns creates modular, composable systems where each server can focus on a specific domain (like\nfile access, web search, or database operations).\nInternet\nYour Computer\nMCP Protocol\nMCP Protocol\nMCP Protocol\nWeb APIs\nHost with MCP Client\n(Claude, IDEs, Tools)\nMCP Server A\nMCP Server B\nMCP Server C\nLocal\nData Source A\nLocal\nData Source B\nRemote\nService C\nCore Primitives\n‚Äã\nMCP defines three fundamental primitives that servers can implement:\nTools\n: Model-controlled functions that LLMs can invoke (like API calls, computations)\nExample: A calculator tool that performs mathematical operations\nImplementation: Functions with defined input/output schemas\nResources\n: Application-controlled data that provides context (like file contents, database records)\nExample: A document resource that provides access to text files\nImplementation: URI-addressable data sources with content types\nPrompts\n: User-controlled templates for LLM interactions\nExample: A summarization prompt template with configurable parameters\nImplementation: Parameterized prompt structures with variables\nFor most developers, tools are the most immediately useful primitive, allowing LLMs to perform actions programmatically.\nTransport Mechanisms\n‚Äã\nMCP supports two main transport mechanisms:\nStdio (Standard IO)\n:\nCommunication over standard input/output streams\nBest for local integrations on the same machine\nSimple setup with no network configuration\nIdeal for development and single-application integrations\nSSE (Server-Sent Events)\n:\nHTTP for client-to-server, SSE for server-to-client\nSuitable for remote connections across networks\nEnables distributed architectures\nRequired for remote accessibility\nRemote Deployment\nSSE Transport\nHTTP POST\n(client to server)\nSSE\n(server to client)\nMCP Client\nMCP Server\nLocal Deployment\nStdio Transport\nstdin/stdout\n(bidirectional)\nMCP Client\nMCP Server\nDevelopers familiar with FastAPI will find implementing MCP servers with SSE transport straightforward, as both use HTTP\nendpoints for receiving requests and support streaming responses using Server-Sent Events.\nBenefits and Ecosystem\n‚Äã\nThe true power of MCP lies in standardization rather than introducing new capabilities:\nReusability\n: Build a server once, use it with any MCP-compatible client\nComposability\n: Combine multiple servers to create complex capabilities\nEcosystem growth\n: Leverage servers created by others\nMCP has rapidly become the standard for LLM tool access with 150+ community servers and multi-language SDK support.\nImplementations use JSON-RPC or RESTful payloads with OAuth authentication, enabling diverse tool providers to connect\nto any MCP-compatible agent. For available servers, see the\nMCP GitHub repository\n.\nProtocol Comparison for Agent-Tool Communication\n‚Äã\nDifferent protocols offer different trade-offs:\nProtocol\nPros\nCons\nUse Cases\nWhen to Choose\nREST/HTTP\nSimple, ubiquitous\nStateless, no streaming\nGeneral tool calls\nFor broad compatibility and simple integrations\ngRPC\nBinary, efficient, supports streaming\nRequires stub generation\nHigh-performance backends\nFor performance-critical pipelines\nWebSockets\nBi-directional, persistent connections\nHarder to scale\nLive tool monitoring\nWhen real-time updates are needed\nGraphQL\nFlexible queries, single endpoint\nSchema complexity\nDynamic data needs\nWhen clients need precise control over data fetching\nMCP\nStandardized for agents, tool introspection\nEarly adoption\nAgent‚Äìtool abstraction layers\nFor standardized agent-tool workflows\nWhen comparing these, one key factor is state and streaming. gRPC and WebSockets allow keeping the \"conversation\" alive,\nwhich can reduce overhead for multiple back-and-forth messages. REST and GraphQL are inherently stateless (each call\nstands alone). Another factor is typing and validation: gRPC and GraphQL have strict schemas, whereas REST relies on\nad-hoc schemas that must be documented separately.\nUses\nUses\nUses\nUses\nAgent\nREST/HTTP\nSimple, ubiquitous\ngRPC\nHigh-performance\nWebSocket\nBi-directional\nMCP\nStandardized\nMCP Roadmap at Lilly\n‚Äã\nWith MCP as the foundation connecting development resources to agent tools and external systems for enterprise-wide AI\nintegration, organizations can streamline workflows, accelerate innovation, and ensure scalable, secure deployment\nacross their digital ecosystem.\nGitHub Template\n‚Ä¢ Reference implementation\n‚Ä¢ Protocol adapters\n‚Ä¢ Documentation\nBackstage\n‚Ä¢ Developer portal\n‚Ä¢ API documentation\n‚Ä¢ Service catalog\nTool Deployment\n‚Ä¢ CATS, Kubed, and other\n‚Ä¢ nodx -> dx support\n‚Ä¢ URI-based access\nModel Context Protocol\n‚Ä¢ Industry standards\n‚Ä¢ Built-in Lilly auth\n‚Ä¢ Multi-modal support\nCortex Toolkit\n‚Ä¢ Unified SDK\n‚Ä¢ Multiple protocol support\n‚Ä¢ Developer resources\nCortex Agents\n‚Ä¢ Tool integration\n‚Ä¢ Agent orchestration\n‚Ä¢ Observability and eval\nDiscovery\n‚Ä¢ Tool exploration\n‚Ä¢ Marketplace for discovery\nand configuration\nExternal Agents\n‚Ä¢ Third-party integration\n‚Ä¢ Cross-platform support\n‚Ä¢ Standardized messaging\nSystem to System\nCompatibility\n‚Ä¢ Cross-platform communication\n‚Ä¢ Agent discovery\n‚Ä¢ Capability negotiation\nAgent to Agent Communication\nAgent2Agent (A2A) Protocol\n‚Äã\nThe Agent2Agent (A2A) protocol, developed by Google with over 50 industry partners, addresses a critical challenge in\nthe AI landscape: enabling AI agents built on diverse frameworks by different companies to communicate and collaborate\neffectively. A2A provides a common language for agents, fostering a more interconnected AI ecosystem.\nKey Components of an A2A Protocol\n‚Äã\nMessage Format\n: The structure of requests and responses. For example, each agent might produce or consume JSON\nthat follows a particular schema (such as an \"intents\" field, a \"metadata\" field, etc.).\nTransport Mechanism\n: How messages travel between agents. This could be over standard web protocols (HTTP/HTTPS) or\nspecialized messaging buses (like gRPC or MQTT).\nDiscovery\n: How an agent finds other agents. This might be analogous to DNS in the internet world or a registry\nservice in the microservices world.\nSecurity and Authentication\n: Ensuring that only authorized agents can talk to each other, or that sensitive data\nis encrypted.\nKey Features and Capabilities\n‚Äã\nA2A enables agents to:\nDiscover capabilities\n: Agents can advertise their skills and find other agents with complementary abilities.\nNegotiate interaction modalities\n: Support for text, structured data, and media exchanges.\nCollaborate on tasks\n: Manage stateful, potentially long-running collaborative tasks.\nMaintain opacity\n: Agents can collaborate without exposing their internal state, memory, or proprietary tools.\nA2A is built on established standards:\nJSON-RPC 2.0 over HTTP(S)\nfor standardized communication\nAgent Cards\nfor capability discovery and connection information\nFlexible interaction modes\nincluding synchronous request/response, streaming (SSE), and asynchronous notifications\nA2A and MCP: Complementary Protocols\n‚Äã\nA2A and MCP serve different but complementary roles in the agentic ecosystem:\nMCP (Model Context Protocol)\n: Connects agents to tools, APIs, and resources with structured inputs/outputs. It's\nhow agents access their capabilities.\nA2A (Agent2Agent Protocol)\n: Facilitates dynamic communication between different agents as peers. It's how agents\ncollaborate, delegate, and manage shared tasks.\nA2A Protocol\nMCP Protocol\nMCP Protocol\nUser\nAgent A\nAgent B\nTool 1\nTool 2\nHow A2A Works\n‚Äã\nA2A facilitates communication between a \"client\" agent and a \"remote\" agent through several key mechanisms:\nCapability Discovery\n: Agents advertise their capabilities using \"Agent Cards\" in JSON format, allowing client\nagents to identify the best agent for a task.\nTask Management\n: Communication is oriented around task completion. The task object has a defined lifecycle and\ncan be completed immediately or monitored over time for long-running operations.\nUser Experience Negotiation\n: Messages include \"parts\" with specified content types, allowing agents to negotiate\nthe correct format and explicitly include UI capabilities like iframes, video, or web forms.\nSecure Collaboration\n: A2A is designed with enterprise-grade authentication and authorization, supporting various\nauthentication schemes.\nAgent Cards\n‚Äã\nAgent Cards are JSON documents that serve as digital \"business cards\" for A2A Servers (remote agents). They are crucial\nfor discovery and initiating interaction, containing:\nIdentity\n: Name, description, and provider information\nService Endpoint\n: URL where the A2A service can be reached\nA2A Capabilities\n: Supported protocol features like streaming or push notifications\nAuthentication\n: Required authentication schemes (e.g., \"Bearer\", \"OAuth2\")\nSkills\n: List of specific tasks the agent can perform, including input/output modes and examples\nClient agents parse these cards to determine if a remote agent is suitable for a task, how to structure requests, and\nhow to communicate securely.\nSecurity Considerations\n‚Äã\nAgent Cards may contain sensitive information that should be protected:\nInternal service URLs\nAuthentication details (though storing actual secrets is discouraged)\nDescriptions of sensitive skills\nProtection mechanisms include access control on endpoints, mutual TLS, network restrictions, and authentication\nrequirements. Agent registries can implement selective disclosure, providing different levels of detail based on the\nclient's identity and permissions.\nThe Challenges of Agent Communication\n‚Äã\nWithout standardized protocols like A2A, organizations face several challenges:\nRedundant Work\n: Every time you add a new AI agent, you need to figure out how it speaks to the rest of your\necosystem, leading to redundant or \"copy-paste\" integration code.\nCompatibility Headaches\n: Suppose your NLP model runs on Python, and your knowledge graph is hosted in a Java-based\nmicroservice. Each might pass around data differently, making it hard for them to play nicely together.\nScaling Bottlenecks\n: As you incorporate more specialized agents (e.g., image recognition, forecasting, robotics),\nthe complexity explodes. Non-standardized communication turns into a big tangly mess, harming your ability to innovate\nquickly.\nBenefits of A2A\n‚Äã\nBreaking Down Silos\n: Connect agents across different ecosystems and frameworks.\nComplex Workflows\n: Enable agents to delegate sub-tasks, exchange information, and coordinate actions.\nInteroperability\n: Agents built on different platforms (LangGraph, CrewAI, Semantic Kernel, custom solutions) can\nwork together.\nModality Agnostic\n: Support for various communication modalities beyond text, including audio and video.\nA2A Design Principles\n‚Äã\nA2A follows five key design principles:\nEmbrace agentic capabilities\n: Focus on enabling collaboration between agents without requiring shared memory,\ntools, or context.\nBuild on existing standards\n: Leverage HTTP, SSE, and JSON-RPC for easier integration with existing IT\ninfrastructure.\nSecure by default\n: Support enterprise-grade authentication and authorization.\nSupport long-running tasks\n: Flexible design for quick tasks and deep research that may take hours or days.\nModality agnostic\n: Support various communication modalities beyond text.\nAgent2Agent Roadmap at Lilly\n‚Äã\ncoming soon!\nThe Future of Agent Interoperability\n‚Äã\nA2A has the potential to unlock a new era of agent interoperability, fostering innovation and creating more versatile\nagentic systems. The protocol is being developed collaboratively as open source, with industry partners working toward a\nproduction-ready version later this year.\nWhat's Next: Protocol Roadmap\n‚Äã\nA2A Protocol Roadmap\nAgent Discovery\nAuthorization schemes and\ncredentials in AgentCard\nAgent Collaboration\nQuerySkill method for\ndynamic capability checking\nTask Lifecycle & UX\nDynamic UX negotiation\nwith mid-task media support\nClient Methods & Transport\nClient-initiated methods and\nimproved streaming reliability\nReferences\ngRPC vs. REST | Postman Blog\nEssential Communication Protocols for Modern Software Architecture: REST, GraphQL, SOAP and More | Medium\nA2A and MCP: Start of the AI Agent Protocol Wars? - Koyeb\nModel Context Protocol (MCP) - Anthropic\nMCP connector - Anthropic\nAnnouncing the Agent2Agent Protocol (A2A) - Google Developers Blog\nSmythOS - Agent Communication Protocols: An Overview\nW3C Autonomous Agents on the Web Community Group\nIETF Agent URI Protocol Draft\nNIST Special Publication 800-207: Zero Trust Architecture\nAgent2Agent Protocol Documentation\nWas this helpful?\nEdit this page\nPrevious\nModel Foundry\nNext\nPositioning\nIndustry Standard Protocols\nEmerging Standards\nModel Context Protocol (MCP)\nOverview and Purpose\nArchitecture and Components\nCore Primitives\nTransport Mechanisms\nBenefits and Ecosystem\nProtocol Comparison for Agent-Tool Communication\nMCP Roadmap at Lilly\nAgent2Agent (A2A) Protocol\nKey Components of an A2A Protocol\nKey Features and Capabilities\nA2A and MCP: Complementary Protocols\nHow A2A Works\nAgent Cards\nThe Challenges of Agent Communication\nBenefits of A2A\nA2A Design Principles\nAgent2Agent Roadmap at Lilly\nThe Future of Agent Interoperability\nWhat's Next: Protocol Roadmap\nCommunity\nEBA Viva Engage\nEBA SharePoint\nQuestions?\nReach us on Viva Engage!\nCopyright ¬© 2026 Eli Lilly and Company",
  "links_found": 6,
  "depth": 3,
  "crawled_at": "2026-02-25T10:08:10.617854"
}